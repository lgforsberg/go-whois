package whois

import (
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"
)

// WhoisServerListURL maps tlds to corresponding whois server list
const WhoisServerListURL = "http://whois-server-list.github.io/whois-server-list/3.0/whois-server-list.xml"

// Maximum size for XML responses to prevent memory exhaustion
const MaxXMLResponseSize = 10 * 1024 * 1024 // 10MB

// DomainList is generated by https://www.onlinetool.io/xmltogo/
// parse xml URL: // ref. http://whois-server-list.github.io/whois-server-list/3.0/whois-server-list.xml
type DomainList struct {
	XMLName     xml.Name `xml:"domainList"`
	Text        string   `xml:",chardata"`
	Version     string   `xml:"version,attr"`
	Date        string   `xml:"date"`
	Description string   `xml:"description"`
	Domain      []struct {
		Text                string `xml:",chardata"`
		Name                string `xml:"name,attr"`
		Source              string `xml:"source"`
		Created             string `xml:"created"`
		Changed             string `xml:"changed"`
		RegistrationService string `xml:"registrationService"`
		State               string `xml:"state"`
		WhoisServer         []struct {
			Text             string `xml:",chardata"`
			Host             string `xml:"host,attr"`
			Source           string `xml:"source"`
			AvailablePattern string `xml:"availablePattern"`
			ErrorPattern     string `xml:"errorPattern"`
			QueryFormat      string `xml:"queryFormat"`
		} `xml:"whoisServer"`
		CountryCode string `xml:"countryCode"`
		Domain      []struct {
			Text        string `xml:",chardata"`
			Name        string `xml:"name,attr"`
			Source      string `xml:"source"`
			WhoisServer []struct {
				Text             string `xml:",chardata"`
				Host             string `xml:"host,attr"`
				Source           string `xml:"source"`
				AvailablePattern string `xml:"availablePattern"`
				ErrorPattern     string `xml:"errorPattern"`
				QueryFormat      string `xml:"queryFormat"`
			} `xml:"whoisServer"`
		} `xml:"domain"`
	} `xml:"domain"`
}

type WhoisServer struct {
	Host     string
	AvailPtn *regexp.Regexp // pattern to check if domain is available
}

// DomainWhoisServerMap stores tld and it's whois server list
// key: tld
// val: list of whoisServer
type DomainWhoisServerMap map[string][]WhoisServer

// NewDomainWhoisServerMap initialize map from 'xmlpath' support local file path and file from web
func NewDomainWhoisServerMap(xmlpath string) (DomainWhoisServerMap, error) {
	content, err := readXMLContent(xmlpath)
	if err != nil {
		return nil, err
	}

	dls := DomainList{}
	if err := xml.Unmarshal(content, &dls); err != nil {
		return nil, err
	}

	DomainWhoisServerMap := make(map[string][]WhoisServer)
	processDomains(dls.Domain, DomainWhoisServerMap)
	applyOverrides(DomainWhoisServerMap)

	return DomainWhoisServerMap, nil
}

func readXMLContent(xmlpath string) ([]byte, error) {
	if strings.HasPrefix(xmlpath, "http") {
		return readXMLFromHTTP(xmlpath)
	}
	return readXMLFromFile(xmlpath)
}

func readXMLFromHTTP(xmlpath string) ([]byte, error) {
	// Use HTTP client with timeout to prevent indefinite hangs
	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Get(xmlpath)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected server resp code: %d", resp.StatusCode)
	}
	// Use LimitReader to prevent unbounded memory consumption
	limitedReader := io.LimitReader(resp.Body, MaxXMLResponseSize)
	return io.ReadAll(limitedReader)
}

func readXMLFromFile(xmlpath string) ([]byte, error) {
	domainXML, err := os.Open(xmlpath)
	if err != nil {
		return nil, err
	}
	defer domainXML.Close()
	return io.ReadAll(domainXML)
}

func processDomains(domains []struct {
	Text                string `xml:",chardata"`
	Name                string `xml:"name,attr"`
	Source              string `xml:"source"`
	Created             string `xml:"created"`
	Changed             string `xml:"changed"`
	RegistrationService string `xml:"registrationService"`
	State               string `xml:"state"`
	WhoisServer         []struct {
		Text             string `xml:",chardata"`
		Host             string `xml:"host,attr"`
		Source           string `xml:"source"`
		AvailablePattern string `xml:"availablePattern"`
		ErrorPattern     string `xml:"errorPattern"`
		QueryFormat      string `xml:"queryFormat"`
	} `xml:"whoisServer"`
	CountryCode string `xml:"countryCode"`
	Domain      []struct {
		Text        string `xml:",chardata"`
		Name        string `xml:"name,attr"`
		Source      string `xml:"source"`
		WhoisServer []struct {
			Text             string `xml:",chardata"`
			Host             string `xml:"host,attr"`
			Source           string `xml:"source"`
			AvailablePattern string `xml:"availablePattern"`
			ErrorPattern     string `xml:"errorPattern"`
			QueryFormat      string `xml:"queryFormat"`
		} `xml:"whoisServer"`
	} `xml:"domain"`
}, DomainWhoisServerMap map[string][]WhoisServer) {
	for _, domain := range domains {
		processWhoisServers(domain.Name, domain.WhoisServer, DomainWhoisServerMap)

		// contains subdomains
		for _, sd := range domain.Domain {
			processWhoisServers(sd.Name, sd.WhoisServer, DomainWhoisServerMap)
		}
	}
}

func processWhoisServers(domainName string, whoisServers []struct {
	Text             string `xml:",chardata"`
	Host             string `xml:"host,attr"`
	Source           string `xml:"source"`
	AvailablePattern string `xml:"availablePattern"`
	ErrorPattern     string `xml:"errorPattern"`
	QueryFormat      string `xml:"queryFormat"`
}, DomainWhoisServerMap map[string][]WhoisServer) {
	if len(whoisServers) > 0 {
		DomainWhoisServerMap[domainName] = make([]WhoisServer, len(whoisServers))
		for i, ws := range whoisServers {
			DomainWhoisServerMap[domainName][i].Host = ws.Host
			if len(ws.AvailablePattern) > 0 {
				ptn, err := regexp.Compile(ws.AvailablePattern)
				if err == nil {
					DomainWhoisServerMap[domainName][i].AvailPtn = ptn
				}
			}
		}
	}
}

func applyOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	// for those domains that only subdomains contains whois server
	// Removed .mc mapping - .mc should use default parser instead of whois.ripe.net
	DomainWhoisServerMap["mm"] = []WhoisServer{{Host: "whois.nic.mm"}}
	ptn, err := regexp.Compile(`\QNo domains matched\E`)
	if err == nil {
		DomainWhoisServerMap["mm"][0].AvailPtn = ptn
	}

	// wrong or unavailable first whois server in whois-server-list.xml
	applyServerOverrides(DomainWhoisServerMap)

	// Not available server
	// in: whois.inregistry.in -> whois.registry.in
	DomainWhoisServerMap["pt"] = []WhoisServer{{Host: "whois.dns.pt"}}
	for k, v := range DomainWhoisServerMap {
		if len(v) > 0 && v[0].Host == "whois.inregistry.in" {
			DomainWhoisServerMap[k] = []WhoisServer{{Host: "whois.registry.in"}}
		}
	}

	// unfilled whois server
	applyArgentinaOverrides(DomainWhoisServerMap)
}

func applyServerOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	overrides := map[string]string{
		"ai":   "whois.nic.ai",   // ai: whois.ai -> whois.nic.ai
		"cyou": "whois.nic.cyou", // cyou: whois.afilias-srs.net -> whois.nic.cyou
		"live": "whois.nic.live", // live: whois.rightside.co -> whois.nic.live
		"vg":   "whois.nic.vg",   // vg: ccwhois.ksregistry.net -> whois.nic.vg
		"surf": "whois.nic.surf", // live: whois-dub.mm-registry.com -> whois.nic.live
	}

	for tld, host := range overrides {
		DomainWhoisServerMap[tld] = []WhoisServer{{Host: host}}
	}
}

func applyArgentinaOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	argentinaTLDs := []string{"ar", "blogspot.com.ar", "com.ar", "edu.ar", "gob.ar",
		"gov.ar", "int.ar", "mil.ar", "net.ar", "org.ar", "tur.ar"}

	for _, tld := range argentinaTLDs {
		DomainWhoisServerMap[tld] = []WhoisServer{{Host: "whois.nic.ar"}}
	}
}

// GetWhoisServer get whois server list given public suffix
// Example:
//
//	ps="pooch.co.uk", search order: "pooch.co.uk" -> "co.uk" -> "uk"
//	ps="co.uk", 	  search order: "co.uk" -> "uk"
func (dsmap DomainWhoisServerMap) GetWhoisServer(ps string) []WhoisServer {
	var wss []WhoisServer
	lvl := strings.Split(ps, ".")
	for i := 1; i <= len(lvl); i++ {
		tlds := strings.SplitN(ps, ".", i)
		if ws, ok := dsmap[tlds[len(tlds)-1]]; ok {
			return ws
		}
	}
	return wss
}
