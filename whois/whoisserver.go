package whois

import (
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"
)

// WhoisServerListURL maps tlds to corresponding whois server list
const WhoisServerListURL = "http://whois-server-list.github.io/whois-server-list/3.0/whois-server-list.xml"

// Maximum size for XML responses to prevent memory exhaustion
const MaxXMLResponseSize = 10 * 1024 * 1024 // 10MB

// DomainList is generated by https://www.onlinetool.io/xmltogo/
// parse xml URL: // ref. http://whois-server-list.github.io/whois-server-list/3.0/whois-server-list.xml
type DomainList struct {
	XMLName     xml.Name `xml:"domainList"`
	Text        string   `xml:",chardata"`
	Version     string   `xml:"version,attr"`
	Date        string   `xml:"date"`
	Description string   `xml:"description"`
	Domain      []struct {
		Text                string `xml:",chardata"`
		Name                string `xml:"name,attr"`
		Source              string `xml:"source"`
		Created             string `xml:"created"`
		Changed             string `xml:"changed"`
		RegistrationService string `xml:"registrationService"`
		State               string `xml:"state"`
		WhoisServer         []struct {
			Text             string `xml:",chardata"`
			Host             string `xml:"host,attr"`
			Source           string `xml:"source"`
			AvailablePattern string `xml:"availablePattern"`
			ErrorPattern     string `xml:"errorPattern"`
			QueryFormat      string `xml:"queryFormat"`
		} `xml:"whoisServer"`
		CountryCode string `xml:"countryCode"`
		Domain      []struct {
			Text        string `xml:",chardata"`
			Name        string `xml:"name,attr"`
			Source      string `xml:"source"`
			WhoisServer []struct {
				Text             string `xml:",chardata"`
				Host             string `xml:"host,attr"`
				Source           string `xml:"source"`
				AvailablePattern string `xml:"availablePattern"`
				ErrorPattern     string `xml:"errorPattern"`
				QueryFormat      string `xml:"queryFormat"`
			} `xml:"whoisServer"`
		} `xml:"domain"`
	} `xml:"domain"`
}

type WhoisServer struct {
	Host     string
	AvailPtn *regexp.Regexp // pattern to check if domain is available
}

// DomainWhoisServerMap stores tld and it's whois server list
// key: tld
// val: list of whoisServer
type DomainWhoisServerMap map[string][]WhoisServer

// NewDomainWhoisServerMap initialize map from 'xmlpath' support local file path and file from web
func NewDomainWhoisServerMap(xmlpath string) (DomainWhoisServerMap, error) {
	content, err := readXMLContent(xmlpath)
	if err != nil {
		return nil, err
	}

	dls := DomainList{}
	if err := xml.Unmarshal(content, &dls); err != nil {
		return nil, err
	}

	DomainWhoisServerMap := make(map[string][]WhoisServer)
	processDomains(dls.Domain, DomainWhoisServerMap)
	applyOverrides(DomainWhoisServerMap)

	return DomainWhoisServerMap, nil
}

func readXMLContent(xmlpath string) ([]byte, error) {
	if strings.HasPrefix(xmlpath, "http") {
		return readXMLFromHTTP(xmlpath)
	}
	return readXMLFromFile(xmlpath)
}

func readXMLFromHTTP(xmlpath string) ([]byte, error) {
	// Use HTTP client with timeout to prevent indefinite hangs
	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Get(xmlpath)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected server resp code: %d", resp.StatusCode)
	}
	// Use LimitReader to prevent unbounded memory consumption
	limitedReader := io.LimitReader(resp.Body, MaxXMLResponseSize)
	return io.ReadAll(limitedReader)
}

func readXMLFromFile(xmlpath string) ([]byte, error) {
	domainXML, err := os.Open(xmlpath)
	if err != nil {
		return nil, err
	}
	defer domainXML.Close()
	return io.ReadAll(domainXML)
}

func processDomains(domains []struct {
	Text                string `xml:",chardata"`
	Name                string `xml:"name,attr"`
	Source              string `xml:"source"`
	Created             string `xml:"created"`
	Changed             string `xml:"changed"`
	RegistrationService string `xml:"registrationService"`
	State               string `xml:"state"`
	WhoisServer         []struct {
		Text             string `xml:",chardata"`
		Host             string `xml:"host,attr"`
		Source           string `xml:"source"`
		AvailablePattern string `xml:"availablePattern"`
		ErrorPattern     string `xml:"errorPattern"`
		QueryFormat      string `xml:"queryFormat"`
	} `xml:"whoisServer"`
	CountryCode string `xml:"countryCode"`
	Domain      []struct {
		Text        string `xml:",chardata"`
		Name        string `xml:"name,attr"`
		Source      string `xml:"source"`
		WhoisServer []struct {
			Text             string `xml:",chardata"`
			Host             string `xml:"host,attr"`
			Source           string `xml:"source"`
			AvailablePattern string `xml:"availablePattern"`
			ErrorPattern     string `xml:"errorPattern"`
			QueryFormat      string `xml:"queryFormat"`
		} `xml:"whoisServer"`
	} `xml:"domain"`
}, DomainWhoisServerMap map[string][]WhoisServer) {
	for _, domain := range domains {
		processWhoisServers(domain.Name, domain.WhoisServer, DomainWhoisServerMap)

		// contains subdomains
		for _, sd := range domain.Domain {
			processWhoisServers(sd.Name, sd.WhoisServer, DomainWhoisServerMap)
		}
	}
}

func processWhoisServers(domainName string, whoisServers []struct {
	Text             string `xml:",chardata"`
	Host             string `xml:"host,attr"`
	Source           string `xml:"source"`
	AvailablePattern string `xml:"availablePattern"`
	ErrorPattern     string `xml:"errorPattern"`
	QueryFormat      string `xml:"queryFormat"`
}, DomainWhoisServerMap map[string][]WhoisServer) {
	if len(whoisServers) > 0 {
		DomainWhoisServerMap[domainName] = make([]WhoisServer, len(whoisServers))
		for i, ws := range whoisServers {
			DomainWhoisServerMap[domainName][i].Host = ws.Host
			if len(ws.AvailablePattern) > 0 {
				ptn, err := regexp.Compile(ws.AvailablePattern)
				if err == nil {
					DomainWhoisServerMap[domainName][i].AvailPtn = ptn
				}
			}
		}
	}
}

func applyOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	// for those domains that only subdomains contains whois server
	// Removed .mc mapping - .mc should use default parser instead of whois.ripe.net
	DomainWhoisServerMap["mm"] = []WhoisServer{{Host: "whois.nic.mm"}}
	ptn, err := regexp.Compile(`\QNo domains matched\E`)
	if err == nil {
		DomainWhoisServerMap["mm"][0].AvailPtn = ptn
	}

	// wrong or unavailable first whois server in whois-server-list.xml
	applyServerOverrides(DomainWhoisServerMap)

	// Not available server
	// in: whois.inregistry.in -> whois.registry.in
	DomainWhoisServerMap["pt"] = []WhoisServer{{Host: "whois.dns.pt"}}
	for k, v := range DomainWhoisServerMap {
		if len(v) > 0 && v[0].Host == "whois.inregistry.in" {
			DomainWhoisServerMap[k] = []WhoisServer{{Host: "whois.registry.in"}}
		}
	}

	// unfilled whois server
	applyArgentinaOverrides(DomainWhoisServerMap)
	applyMalaysiaOverrides(DomainWhoisServerMap)
	applyColombiaOverrides(DomainWhoisServerMap)
	applyIndiaOverrides(DomainWhoisServerMap)
	applySouthAfricaOverrides(DomainWhoisServerMap)
	applyAfiliasMigrationOverrides(DomainWhoisServerMap)
}

func applyServerOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	overrides := map[string]string{
		"ai":   "whois.nic.ai",       // ai: whois.ai -> whois.nic.ai
		"live": "whois.nic.live",     // live: whois.rightside.co -> whois.nic.live
		"vg":   "whois.nic.vg",       // vg: ccwhois.ksregistry.net -> whois.nic.vg
		"surf": "whois.nic.surf",     // surf: whois-dub.mm-registry.com -> whois.nic.surf
		"shop": "whois.nic.shop",     // shop: missing from XML
		"fun":  "whois.nic.fun",      // fun: missing from XML
		"hair": "whois.nic.hair",     // hair: missing from XML
		"gay":  "whois.nic.gay",      // gay: missing from XML
		"sg":   "whois.sgnic.sg",     // sg: incorrect in XML
		"vip":  "whois.nic.vip",      // vip: whois-dub.mm-registry.com (dead) -> whois.nic.vip
		"fit":  "whois.nic.fit",      // fit: whois-dub.mm-registry.com (dead) -> whois.nic.fit
		"beer": "whois.nic.beer",     // beer: whois-dub.mm-registry.com (dead) -> whois.nic.beer
		// Private suffixes with own WHOIS servers
		"it.com": "whois.it.com",     // it.com: private suffix, similar to co.uk
		// Note: .cyou moved to applyAfiliasMigrationOverrides
		// Note: .co and subdomains moved to applyColombiaOverrides
		// Note: .in and subdomains moved to applyIndiaOverrides
	}

	for tld, host := range overrides {
		DomainWhoisServerMap[tld] = []WhoisServer{{Host: host}}
	}
}

func applyArgentinaOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	argentinaTLDs := []string{"ar", "blogspot.com.ar", "com.ar", "edu.ar", "gob.ar",
		"gov.ar", "int.ar", "mil.ar", "net.ar", "org.ar", "tur.ar"}

	for _, tld := range argentinaTLDs {
		DomainWhoisServerMap[tld] = []WhoisServer{{Host: "whois.nic.ar"}}
	}
}

func applyMalaysiaOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	// Malaysia TLDs migrated to Tucows Registry Backend
	// Old server whois.mynic.net.my is dead (DNS lookup fails)
	// New server whois.mynic.my handles all .my domains and subdomains
	malaysiaTLDs := []string{"my", "blogspot.my", "com.my", "edu.my", "gov.my",
		"mil.my", "name.my", "net.my", "org.my"}

	for _, tld := range malaysiaTLDs {
		DomainWhoisServerMap[tld] = []WhoisServer{{Host: "whois.mynic.my"}}
	}
}

func applyColombiaOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	// Colombia TLDs migrated to CentralNic Registry Backend
	// Old server whois.nic.co is dead (DNS lookup fails)
	// New server whois.registry.co handles all .co domains and subdomains
	colombiaTLDs := []string{"co", "com.co", "net.co", "nom.co", "edu.co", "gov.co",
		"mil.co", "org.co", "blogspot.com.co"}

	for _, tld := range colombiaTLDs {
		DomainWhoisServerMap[tld] = []WhoisServer{{Host: "whois.registry.co"}}
	}
}

func applyIndiaOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	// India TLDs migrated to NIXI Registry Backend
	// Old server whois.registry.in is dead (DNS lookup fails)
	// New server whois.nixiregistry.in handles all .in domains and subdomains
	indiaTLDs := []string{"in", "co.in", "net.in", "org.in", "ac.in", "edu.in",
		"ernet.in", "firm.in", "gen.in", "gov.in", "ind.in", "mil.in", "nic.in",
		"res.in", "blogspot.in"}

	for _, tld := range indiaTLDs {
		DomainWhoisServerMap[tld] = []WhoisServer{{Host: "whois.nixiregistry.in"}}
	}
}

func applySouthAfricaOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	// South Africa .za TLDs operated by ZARC (ZA Registry Consortium)
	// All servers return "Available" for unregistered domains
	// The XML file has correct servers but missing availablePattern

	availPtn, _ := regexp.Compile(`^Available`)

	// Map of .za subdomains to their specific WHOIS servers
	zaOverrides := map[string]string{
		"co.za":  "coza-whois.registry.net.za",
		"net.za": "net-whois.registry.net.za",
		"org.za": "org-whois.registry.net.za",
		"web.za": "web-whois.registry.net.za",
	}

	for tld, host := range zaOverrides {
		DomainWhoisServerMap[tld] = []WhoisServer{{Host: host, AvailPtn: availPtn}}
	}

	// These .za subdomains use whois.ac.za or whois.co.za as fallback
	// but have their own specific servers in the registry.net.za infrastructure
	// that also use the same "Available" pattern
}

func applyAfiliasMigrationOverrides(DomainWhoisServerMap map[string][]WhoisServer) {
	// Afilias Migration (2020-2024): During the Afilias → Identity Digital transition,
	// 192 TLDs were affected. Of these:
	// - 128 TLDs migrated to new WHOIS servers (mostly whois.nic.<tld>)
	// - 66 TLDs abandoned WHOIS entirely (no server in IANA, RDAP only)
	//
	// This function maps the 128 TLDs that still have WHOIS support to their new servers.
	// The old Afilias infrastructure (whois.afilias-srs.net, whois.afilias.net, whois.afilias.info)
	// now returns "TLD is not supported" for all affected TLDs.
	
	overrides := map[string]string{
		"abbott":       "whois.nic.abbott",
		"aco":          "whois.nic.aco",
		"adult":        "whois.nic.adult",
		"agakhan":      "whois.nic.agakhan",
		"akdn":         "whois.nic.akdn",
		"alibaba":      "whois.nic.alibaba",
		"alipay":       "whois.nic.alipay",
		"allstate":     "whois.nic.allstate",
		"ally":         "whois.nic.ally",
		"audi":         "whois.nic.audi",
		"autos":        "whois.nic.autos",
		"bcg":          "whois.nic.bcg",
		"beats":        "whois.nic.beats",
		"bestbuy":      "whois.nic.bestbuy",
		"blockbuster":  "whois.nic.blockbuster",
		"bnpparibas":   "whois.nic.bnpparibas",
		"boats":        "whois.nic.boats",
		"boehringer":   "whois.nic.boehringer",
		"case":         "whois.nic.case",
		"cern":         "whois.nic.cern",
		"cipriani":     "whois.nic.cipriani",
		"clinique":     "whois.nic.clinique",
		"creditunion":  "whois.nic.creditunion",
		"cyou":         "whois.nic.cyou",
		"delta":        "whois.nic.delta",
		"dish":         "whois.nic.dish",
		"dot":          "whois.nic.dot",
		"dtv":          "whois.nic.dtv",
		"dvr":          "whois.nic.dvr",
		"eco":          "whois.nic.eco",
		"edeka":        "whois.nic.edeka",
		"emerck":       "whois.nic.emerck",
		"extraspace":   "whois.nic.extraspace",
		"fage":         "whois.nic.fage",
		"fedex":        "whois.nic.fedex",
		"ferrari":      "whois.nic.ferrari",
		"fido":         "whois.nic.fido",
		"gallup":       "whois.nic.gallup",
		"gea":          "whois.nic.gea",
		"godaddy":      "whois.nic.godaddy",
		"goodyear":     "whois.nic.goodyear",
		"hdfc":         "whois.nic.hdfc",
		"hdfcbank":     "whois.nic.hdfcbank",
		"helsinki":     "whois.nic.helsinki",
		"hermes":       "whois.nic.hermes",
		"hiv":          "whois.tucowsregistry.net",
		"hkt":          "whois.nic.hkt",
		"homedepot":    "whois.nic.homedepot",
		"homes":        "whois.nic.homes",
		"hughes":       "whois.nic.hughes",
		"icbc":         "whois.nic.icbc",
		"imamat":       "whois.nic.imamat",
		"ismaili":      "whois.nic.ismaili",
		"ist":          "whois.nic.ist",
		"istanbul":     "whois.nic.istanbul",
		"itv":          "whois.nic.itv",
		"jeep":         "whois.nic.jeep",
		"jll":          "whois.nic.jll",
		"kosher":       "whois.nic.kosher",
		"lamborghini":  "whois.nic.lamborghini",
		"lamer":        "whois.nic.lamer",
		"lasalle":      "whois.nic.lasalle",
		"latino":       "whois.nic.latino",
		"lds":          "whois.nic.lds",
		"locker":       "whois.nic.locker",
		"ltda":         "whois.nic.ltda",
		"marriott":     "whois.nic.marriott",
		"mckinsey":     "whois.nic.mckinsey",
		"merckmsd":     "whois.nic.merckmsd",
		"mit":          "whois.nic.mit",
		"monster":      "whois.nic.monster",
		"mormon":       "whois.nic.mormon",
		"moto":         "whois.nic.moto",
		"motorcycles":  "whois.nic.motorcycles",
		"nokia":        "whois.nic.nokia",
		"nowtv":        "whois.nic.nowtv",
		"nra":          "whois.nic.nra",
		"ollo":         "whois.nic.ollo",
		"onl":          "whois.nic.onl",
		"origins":      "whois.nic.origins",
		"ott":          "whois.nic.ott",
		"pccw":         "whois.nic.pccw",
		"pnc":          "whois.nic.pnc",
		"porn":         "whois.nic.porn",
		"progressive":  "whois.nic.progressive",
		"pwc":          "whois.nic.pwc",
		"redumbrella":  "whois.nic.redumbrella",
		"rich":         "whois.nic.rich",
		"richardli":    "whois.nic.richardli",
		"rogers":       "whois.nic.rogers",
		"sbi":          "whois.nic.sbi",
		"scholarships": "whois.nic.scholarships",
		"sew":          "whois.nic.sew",
		"sex":          "whois.nic.sex",
		"sina":         "whois.nic.sina",
		"sling":        "whois.nic.sling",
		"srl":          "whois.nic.srl",
		"stada":        "whois.nic.stada",
		"star":         "whois.nic.star",
		"statebank":    "whois.nic.statebank",
		"stockholm":    "whois.nic.stockholm",
		"storage":      "whois.nic.storage",
		"temasek":      "whois.nic.temasek",
		"thd":          "whois.nic.thd",
		"travelers":    "whois.nic.travelers",
		"travelersinsurance": "whois.nic.travelersinsurance",
		"trv":     "whois.nic.trv",
		"tvs":     "whois.nic.tvs",
		"ups":     "whois.nic.ups",
		"vegas":   "whois.nic.vegas",
		"vig":     "whois.nic.vig",
		"viking":  "whois.nic.viking",
		"weibo":   "whois.nic.weibo",
		"wolterskluwer": "whois.nic.wolterskluwer",
		"xin":     "whois.nic.xin",
		"yachts":  "whois.nic.yachts",
		"zara":    "whois.nic.zara",
		// Internationalized TLDs (punycode)
		"xn--mgbca7dzdo":   "whois.nic.xn--mgbca7dzdo",   // ابوظبي
		"xn--4gbrim":       "whois.nic.xn--4gbrim",       // موقع
		"xn--fiq228c5hs":   "whois.teleinfo.cn",          // 中文网
		"xn--3ds443g":      "whois.teleinfo.cn",          // 在线
		"xn--9krt00a":      "whois.nic.xn--9krt00a",      // 微博
		"xn--kput3i":       "whois.nic.xn--kput3i",       // 手机
		"xn--b4w605ferd":   "whois.nic.xn--b4w605ferd",   // 淡马锡
		"xn--5tzm5g":       "whois.nic.xn--5tzm5g",       // 网站
		"xn--g2xx48c":      "whois.nic.xn--g2xx48c",      // 购物
		"xn--fzys8d69uvgm": "whois.nic.xn--fzys8d69uvgm", // 電訊盈科
	}

	for tld, host := range overrides {
		DomainWhoisServerMap[tld] = []WhoisServer{{Host: host}}
	}
	
	// Remove entries for 66 TLDs that have NO WHOIS server at all (RDAP only)
	// These TLDs have empty whois: field in IANA and the old Afilias servers
	// reject them with "TLD is not supported"
	noWhoisTLDs := []string{
		"abarth", "abbvie", "active", "aigo", "alfaromeo", "apple", "avianca",
		"bet", "black", "blue", "bnl", "bugatti", "buy", "caseih", "cbs", "ceb",
		"chrysler", "dabur", "dodge", "dstv", "dunlop", "esurance", "fiat",
		"global", "goodhands", "green", "info", "irish", "iveco", "jcp", "kim",
		"lancia", "lgbt", "lotto", "maserati", "meet", "metlife", "mobi", "mopar",
		"natura", "newholland", "organic", "orientexpress", "origin", "payu", "pet",
		"pink", "poker", "pro", "promo", "red", "redstone", "shaw", "shiksha",
		"showtime", "shriram", "srt", "uconnect", "volkswagen", "vote", "voto",
		// Internationalized TLDs (punycode)
		"xn--55qx5d8y0buji4b930a", // 大众汽车
		"xn--czru2d",              // 工行
		"xn--6frz82g",             // 移动
		"xn--kprw13d",             // 臺灣
		"xn--rhqv96g",             // 诺基亚
	}
	
	for _, tld := range noWhoisTLDs {
		delete(DomainWhoisServerMap, tld)
	}
}

// GetWhoisServer get whois server list given public suffix
// Example:
//
//	ps="pooch.co.uk", search order: "pooch.co.uk" -> "co.uk" -> "uk"
//	ps="co.uk", 	  search order: "co.uk" -> "uk"
func (dsmap DomainWhoisServerMap) GetWhoisServer(ps string) []WhoisServer {
	var wss []WhoisServer
	lvl := strings.Split(ps, ".")
	for i := 1; i <= len(lvl); i++ {
		tlds := strings.SplitN(ps, ".", i)
		if ws, ok := dsmap[tlds[len(tlds)-1]]; ok {
			return ws
		}
	}
	return wss
}
